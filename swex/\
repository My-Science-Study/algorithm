#include <iostream>
#define TABLESIZE 5e6
using namespace std;

struct edge
{
  int v, w;
  edge () {};
  edge(int v, int w) : v(v), w(w) {};
};

struct node
{
  int u; 
  long long dist;
  node() {};
  node(int u, long long dist) : u(u), dist(dist) { };
};

struct priority_queue
{
  node array[(int)2e6];
  int len; 
  priority_queue() : len(0) {};

  void push(node a) 
  {
    array[len++] = a; 
    swap(0, len-1);
    heapify(0);
  }
  node top() { return array[0]; }
  void pop() 
  {
    swap(0, len-1);
    len--; 
    heapify(0);
  }

  void swap(int i, int j)
  {
    node tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
  }

  void heapify(int i)
  {
    int mx = i;
    int left = i*2+1;

    if ( left < len && array[mx].dist < array[left].dist ) mx = left;

    int right = i*2+1;
    if ( right < len && array[mx].dist < array[right].dist ) mx = right;

    if ( mx != i ) 
    {
      swap(i, mx);
      heapify(mx);
    }
  }

  void build_heap() { for (int i=len/2; i>=0; i--) heapify(i); };

  bool empty() { return len == 0; }
};

struct data 
{
  int user, id;
  bool used;
  data(int x, int y ) : user(x), id(y) {};
  data() {};
};

edge eId[(int)1e6]; 
data table[TABLESIZE];

int hashfunc(int a) { return (a*a*a)%TABLESIZE; }

int myElen[(int)2e5];
long long d[(int)2e5];
int idx=0;
priority_queue pq; 
 
int main()
{
  int T;
  int tt = 0;
  cin >> T;
  while (++tt <= T )
  {
    int n, m;
    cin >> n >> m;
    for (int i=0; i<n; i++) myElen[i] = 0;
    for (int i=0; i<TABLESIZE; i++) table[i].used = false;
    idx =0;

    for (int i=0; i<m; i++)
    {
      int u, v, w;
      cin >> u >> v >> w;
      //u--, v--;

      eId[idx] = edge(v, w);
      int desired_table_idx = hashfunc( u );
      while( true )
      {
        if ( TABLEISZE == desired_table_idx ) desired_table_idx = 0;
        

      }
      myE[myElen[u]] = idx++;
      myElen[u]++; 

      eId[idx] = edge(u, w);
      myE[myElen[v]] = idx++;  
      myElen[v]++;
    }
    for (int i=0; i<n; i++) d[i]= 2e15;
    pq.push(node(1, 0));
    d[1] = 0;
    for (int i=0; i<myElen[1]; i++)
    {
      cout << eId[myE[1]].v << " " <<  eId[myE[1]].w << "\n";
    }

    while(!pq.empty())
    {
      node cur = pq.top();
      int now = cur.u;

      cout << now << "\n";
      long long dist = -cur.dist;
      pq.pop();
      if ( d[now] <  dist ) continue;

      for (int i=0; i< myElen[now]; i++)
      {

        int id = myE[i];
        edge ee = eId[id];
        int next = ee.v;
        cout << next << " ";
        long long nextDist = dist + ee.w;

        if ( d[next] > d[nextDist] ) 
        {
          pq.push(node(next, -nextDist));
        }
      }
      cout <<  "\n";
    }

    long long ans = 0;
    for (int i=0; i<n; i++) ans += d[i];
    cout << "#" << tt << " " << ans << "\n";
  }
}
